// ============================================================
// Grafana Alloy Configuration (logs-only)
// Docker 컨테이너 로그를 수집하여 Loki로 전송
// ============================================================

discovery.docker "container_logs" {
  host             = "unix:///var/run/docker.sock"
  refresh_interval = "5s"
}

loki.process "container_logs" {
  forward_to = [loki.write.default.receiver]

  stage.replace {
    expression = "([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+)"
    replace    = "****@****.***"
  }

  stage.json {
    expressions = {
      level = "level",
      msg   = "message",
    }
  }

  stage.labels {
    values = {
      level = null,
    }
  }
}

discovery.relabel "container_logs" {
  # Docker 디스커버리 결과를 받아서 라벨 재구성을 수행합니다.
  # targets가 비어 있으면 Loki로 전송할 대상이 없어집니다.
  targets = discovery.docker.container_logs.targets

  rule {
    source_labels = ["__meta_docker_container_state"]
    regex         = "exited|dead|created|removing|restarting|paused"
    action        = "drop"
  }

  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "/(.*)"
    target_label  = "container"
  }

  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label  = "service"
  }
}

loki.source.docker "container_logs" {
  host             = "unix:///var/run/docker.sock"
  # 라벨 재구성이 반영된 타깃을 사용해야 정확한 대상만 수집됩니다.
  targets          = discovery.relabel.container_logs.targets
  forward_to       = [loki.process.container_logs.receiver]
  relabel_rules    = discovery.relabel.container_logs.rules
  refresh_interval = "5s"
}

loki.write "default" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
  }
  external_labels = {}
}
